# -*- coding: utf-8 -*-
"""Rock Paper Scissors.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BnbhornA_WJUAIsBedlpBa3ja9H-A7Wt
"""

# RPS.py

import random

def player(prev_play, opponent_history=[]):
    # Guardar historial del oponente
    if prev_play:
        opponent_history.append(prev_play)

    # Opciones posibles
    choices = ["R", "P", "S"]

    # Funci칩n para elegir el movimiento que gana a otro
    def win_against(move):
        if move == "R": return "P"
        if move == "P": return "S"
        if move == "S": return "R"

    # Primer movimiento
    if len(opponent_history) < 3:
        return random.choice(choices)

    # --- Estrategia 1: Detecci칩n de patrones de 3 jugadas ---
    last_three = "".join(opponent_history[-3:])
    patterns = {}

    # Crear un diccionario de secuencias -> siguiente movimiento m치s frecuente
    for i in range(len(opponent_history) - 3):
        seq = "".join(opponent_history[i:i+3])
        next_move = opponent_history[i+3]
        if seq not in patterns:
            patterns[seq] = {"R": 0, "P": 0, "S": 0}
        patterns[seq][next_move] += 1

    # Si se detecta un patr칩n, predecir el siguiente
    if last_three in patterns:
        prediction = max(patterns[last_three], key=patterns[last_three].get)
        return win_against(prediction)

    # --- Estrategia 2: Contar movimientos frecuentes ---
    counts = {"R": 0, "P": 0, "S": 0}
    for move in opponent_history:
        counts[move] += 1
    prediction = max(counts, key=counts.get)

    return win_against(prediction)